# 프로세스란?
> 프로세스의 개념, PCB, Context Switching, 프로세스 주소 공간, 프로세스 상태, 계층 구조, 생성 기법에 대해 알아보자

## 프로세스(Process)
실행 중인 프로그램, 보조기억 장치에 저장된 프로그램을 메모리에 적재하고 실행된 상태를 말한다.    

프로세스의 종류로 사용자가 보는 앞에서 프로세스인 **포그라운드 프로세스(foreground process)** 와 사용자가 보지 못하는 뒤편에서 실행되는
**백그라운드 프로세스(background process)** 가 있다. 백그라운드 프로세스 중에는 시스템 부팅 시에 시작되어 종료 시까지 실행되며,
사용자 인터페이스 없이 독립적으로 실행하여 특정 서비스를 제공하는 프로세스인 **데몬(demon)** 이 존재한다.

## 프로세스 제어 블록(PCB, Process Control Block)
PCB는 프로세스와 관련된 정보를 저장하는 **자료구조**이다. 해당 프로세스를 식별하기 위해 꼭 필요한 정보들이 저장된다.
PCB는 커널 영역에 생성된다. 운영체제는 수많은 프로세스들 사이에서 PCB로 특정 프로세스를 식별하고 해당 프로세스를 처리하는 데 
필요한 정보를 판단한다.    

운영체제가 '프로세스를 생성했다'는 말은 '운영체제가 PCB를 생성했다'는 말과 같다.

### PCB에 담기는 정보
1. **프로세스 ID, PID**    
   특정 프로세스를 식별하기 위해 부여하는 고유한 번호
2. **레지스터 값**    
   해당 프로세스를 실행하면 사용했던 pc를 포함한 레지스터 값을 담는다.
3. **프로세스 상태**    
   현재 프로세스가 어떤 상태인지 기록
4. **CPU 스케줄링 정보**    
   프로세스가 언제, 어떤 순서로 CPU를 할당 받을지에 대한 정보
5. **메모리 관리 정보**    
   프로세스가 어느 주소에 저장되었는지에 대한 정보
6. **사용자 파일과 입출력장치 목록**    
   프로세스가 실행 과정에서 사용한 특정 입출력장치나 파일 정보

## 문맥 교환(Context Switching)
A 프로세스를 실행하다가 B 프로세스를 실행하고, 다시 A 프로세스를 실행하기 위해서는 A 프로세스에서 B 프로세스로 전환될 때
A 프로세스의 정보를 백업해두어야 한다. 그래야만 B 프로세스 실행이 끝나서 다시 A 프로세스를 실행하려고 할 때 이어서 다시 실행할 수 있기 때문이다.
이렇게 하나의 프로세스 수행을 재개하기 위해 기억해야 하는 정보를 **문맥(context)** 라고 한다. 하나의 프로세스 문맥은 해당 PCB에 표현되어 있다.    

이처럼 기존 프로세스 문맥을 PCB에 기록하고, 새로운 프로세스를 실행하기 위해 문맥을 PCB로부터 복구하여 새로운 프로세스를 실행하는 것을
**문맥 교환**이라고 한다.    

문맥 교환을 너무 자주 하면 오버헤드가 일어날 수 있기 때문에 문맥 교환이 자주 일어난다고 해서 반드시 좋다고 할 수는 없다.

## 프로세스의 메모리 영역
프로세스가 실행되면 커널 영역에 PCB가 생성된다. 사용자 영역에는 프로세스가 **코드 영역, 데이터 영역, 힙 영역, 스택 영역**으로 나뉘어 저장된다.    

<img src="https://github.com/chunghye98/CS-Archive/assets/57451700/873a3b87-8cf5-4904-b373-90f4eba9dd6e" width="30%">

1. **코드 영역 code segment**    
   실행할 수 있는 코드, 기계어로 이루어진 명령어가 저장된다. 데이터가 아닌 CPU가 실행할 명령어를 저장하기 때문에 read-only 공간이다.
2. **데이터 영역 data segment**    
   프로그램이 실행되는 동안 유지할 데이터가 저장되는 공간, **전역 변수** 등을 저장한다.
3. **힙 영역 heap segment**    
   프로그램을 만드는 사용자, 즉 프로그래머가 직접 할당할 수 있는 저장 공간이다. 힙 영역에 메모리를 할당했다면 언젠가는 해당 공간을 반환해야 한다.
    메모리 공간을 반환하지 않는다면 메모리 누수(memory leak)가 일어난다. Java는 GC가 프로그램이 사용하지 않는 메모리를 자동으로 찾아내어 해제하는 역할을 한다.
4. **스택 영역 stack segment**    
   데이터를 일시적으로 저장하는 공간, 함수의 실행이 끝나면 사라지는 매개변수, 지역변수 등이 저장된다.

<img src="https://github.com/chunghye98/CS-Archive/assets/57451700/418170c0-306c-46f6-be9a-efa87bc36cce" width="30%">

코드 영역과 데이터 영역은 크기가 변하지 않기 때문에 **정적 할당 영역**이라고 부르고, 힙 영역과 스택 영역은 프로세스 실행 과정에서 크기가 변할 수 있기 때문에
**동적 할당 영역**이라 부른다.

## 프로세스의 상태
PCB에 저장되는 프로세스의 상태는 다음과 같다.

<img src="https://github.com/chunghye98/CS-Archive/assets/57451700/7c2b05c6-d922-4e86-94f8-37b5ceeb1602" width="40%">

1. **생성 상태 new**    
   막 메모리에 적재되어 PCB를 할당 받은 상태이다. CPU의 할당을 기다린다.
2. **준비 상태 ready**    
   차례가 되면 CPU를 할당 받아 실행 상태가 된다.
3. **실행 상태 running**    
   CPU를 할당 받아 실행 중인 상태를 의미한다. 할당된 일정 시간 동안만 CPU를 사용할 수 있다. 타이머 인터럽트가 발생하면 다시 준비 상태가 되고,
   입출력장치를 사용해야 한다면 입출력장치의 작업이 끝날 때까지 대기 상태가 된다.
4. **대기 상태 blocked**    
   입출력장치의 작업을 기다리는 상태를 의미한다. 작업이 완료되면 해당 프로세스는 준비상태로 전환되어 CPU 할당을 기다린다.
5. **종료 상태 terminated**    
   프로세스가 종료된 상태이다. 운영체제는 PCB와 프로세스가 사용한 메모리를 정리한다.

## 프로세스 계층 구조
프로세스는 실행 도중 시스템 호출을 통해 다른 프로세스를 생성할 수 있다. 이때 새 프로세스를 실행한 프로세스를 부모 프로세스(parent process),
생성된 프로세스를 자식 프로세스(child process)라 한다. 많은 운영체제가 부모-자식 구조로 프로세스를 관리한다.    

컴퓨터가 부팅될 때 실행되는 최초의 프로세스가 자식 프로세스들을 생성하고, 생성된 자식 프로세스들이 새로운 프로세스들을 낳는 형식이다.    
최초 프로세스는 유닉스 운영체제에서 init, 리눅스 운영체제에서는 systemd, macOS에서는 launchd라고 한다. PID는 항상 1번이다.

## 프로세스 생성 기법
1. 부모 프로세스는 fork()로 자신의 복사본을 자식 프로세스로 생성한다.
2. 자식 프로세스는 exec()으로 자신의 메모리 공간을 다른 프로그램으로 교체한다.

## 참고
혼자 공부하는 컴퓨터구조 + 운영체제  