# CPU 스케줄링이란?
> CPU 스케줄링, 스케줄링 큐, CPU 스케줄링 알고리즘 종류에 대해 알아보자

## CPU 스케줄링(CPU Scheduling)
운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것을 말한다. CPU 스케줄링이 합리적이지 않으면 
반드시 실행되어야 할 프로세스들이 실행되지 못하거나, 당장 급하지 않은 프로세스들만 주로 실행되는 등 무질서한 상태가 발생할 수 있다.

프로세스마다 우선 순위가 다르다. 입출력 작업이 많은 입출력 집중 프로세스(I/O bound process)는 실행 상태보다 입출력을 위한 대기 상태에
많이 머무른다. 반면 CPU 작업이 많은 CPU 집중 프로세스(CPU bound process)는 대기 상태보다 실행 상태에 더 많이 머무르게 된다. 따라서, 
두 프로세스가 동시에 CPU 자원을 요구했을 때, 입출력 집중 프로세스를 빠르게 실행시키고, CPU 집중 프로세스에 집중적으로 CPU에 할당하는 것이 더 효율적이다.

프로세스의 중요도에 맞게 CPU를 이용할 수 있도록 하기 위해 운영체제는 프로세스마다 우선순위(priority)를 부여한다.
각 프로세스의 PCB에 운선순위를 명시하고, PCB에 적힌 우선순위를 기준으로 먼저 처리할 프로세스를 결정한다.

## 스케줄링 큐(Scheduling Queue)
CPU를 사용할 다음 프로세스를 찾기 위해 운영체제가 일일이 모든 PCB를 검색하는 것은 비효율적이다. 운영체제는 CPU를 사용하고 싶은 
프로세스들, 메모리에 적재되고 싶은 프로세스들, 특정 입출력장치를 사용하고 싶은 프로세스를 **스케줄링 큐**로 구현하고 관리한다. 이 스케줄링 
큐는 커널에 구현되어 있다.
> 여기서 큐는 반드시 FIFO일 필요는 없다. 대기열의 의미로 사용된다.

### 스케줄링 큐의 종류
1. **준비 큐 Ready Queue**    
   CPU를 이용하고 싶은 프로세스들이 서는 줄이다.
2. **대기 큐 Waiting Queue**    
   입출력장치를 이용하기 위해 대기 상태에 접어든 프로세스들이 서는 줄이다.

<img src="https://github.com/chunghye98/CS-Archive/assets/57451700/4d2b8fbd-141b-4911-a912-f6824f13a1a8" width="40%">

## 선점형 스케줄링과 비선점형 스케줄링
### 선점형 스케줄링 preemptive scheduling
프로세스가 CPU를 비롯한 자원을 사용하고 있더라도 운영체제가 프로세스로부터 자원을 강제로 빼앗아 다른 프로세스에 할당할 수 있는 스케줄링 방식이다.    
- 장점: 한 프로세스의 자원 독점을 방지하고 골고루 자원을 분배할 수 있다.    
- 단점: 문맥 교환 과정에서 오버헤드가 일어날 수 있다.

### 비선점형 스케줄링 non-preemptive scheduling
하나의 프로세스가 자원을 사용하고 있다면 그 프로세스가 종료되거나 스스로 대기 상태에 접어들기 전까진 다른 프로세스가 끼어들 수 없는 스케줄링 방식이다.    
- 장점: 문맥 교환 횟수가 적어 오버헤드가 선점형 스케줄링 방식보다 적다.    
- 단점: 하나의 프로세스가 자원을 사용 중이라면 당장 자원을 사용해야 하는 상황에서도 기다려야 한다.

## CPU 스케줄링 알고리즘의 종류
### 선입 선처리 스케줄링 (First Come First Served, FCFS)
단순히 준비 큐에 삽입된 순서대로 프로세스들을 처리하는 비선점형 스케줄링 방식이다. CPU를 오래 사용하는 프로세스가 먼저 도착하면 짧은 태스크들이
오래 기다려야 하는 **호위 효과(convoy effect)** 가 일어날 수 있다.

### 최단 작업 우선 스케줄링(Shortest Job First, SJF)
CPU 사용 시간이 짧은 프로세스부터 실행하는 비선점형 스케줄링 방식이다.

### 라운드 로빈 스케줄링(Round Robin)
정해진 타임 슬라이스만큼의 시간 동안 돌아가며 CPU를 이용하는 선점형 스케줄링이다.    
큐에 삽입된 순서대로 CPU를 이용하되 타임 슬라이스만큼 사용해도 프로세스가 완료되지 않았다면 다시 큐의 맨 뒤에 삽입된다. 이때 문맥교환이 일어난다.    
타임 슬라이스가 너무 크면 선입 선처리 스케줄링과 다를 바 없고, 너무 작으면 문맥 교환이 빈번하게 발생해 오버헤드가 증가할 수 있다.

### 최소 잔여 시간 우선 스케줄링(Shortest Remaining Time, SRT)
프로세스들은 정해진 타임 슬라이스만큼 CPU를 사용하되, CPU를 사용할 다음 프로세스로는 남아있는 작업 시간이 가장 적은 프로세스가 선택되는
선점형 스케줄링이다.

### 우선순위 스케줄링(Priority)
프로세스들에 우선 순위를 부여하고, 가장 높은 우선순위부터 처리하는 선점형 스케줄링이다. 우선순위가 낮은 프로세스들은 계속 실행이 연기되는 
**기아(starvation)** 현상이 일어날 수 있다. 이를 방지하기 위해 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 **에이징(aging)** 기법을 
사용할 수 있다.

### 다단계 큐 스케줄링(Multilevel-Queue)
우선 순위가 가장 높은 큐에 있는 프로세스들을 먼저 처리하고, 우선 순위가 높은 큐가 비어 있으면 그다음 우선순위 큐에 있는 프로세스들을 처리하는 선점형 스케줄링이다.
우선순위 0의 프로세스들 -> 우선순위 1의 프로세스들 -> 우선순위 2에 삽입된 프로세스들 -> ... 순으로 CPU를 할당 받는다.

이렇게 큐를 여러 개 두면 프로세스 유형별로 우선순위를 구분하여 실행하는 것이 편리해진다. 
큐별로 타임 슬라이스를 여러 개 지정할 수도 있고, 큐마다 다른 스케줄링 알고리즘을 사용할 수도 있다.
프로세스들이 큐 사이를 이동할 수 없기 때문에 기아 현상이 발생할 수 있다.

<img src="https://github.com/chunghye98/CS-Archive/assets/57451700/3f671253-374b-40c7-bfa6-2f42ddb6776b" width="40%">

### 다단계 피드백 큐 스케줄링(Multilevel-Feedback-Queue)
다단계 큐 스케줄링에서 프로세스들이 큐 사이들 이동할 수 있는 선점형 스케줄링 방식이다. 어떤 프로세스의 CPU 이용 시간이 길면 낮은
우선순위 큐로 이동시키고, 어떤 프로세스가 낮은 우선순위 큐에서 너무 오래 기다린다면 높은 우선순위 큐로 이동시킬 수 있는 알고리즘이다.
일반적으로 CPU 스케줄링 알고리즘으로 사용되는 방식이다.

<img src="https://github.com/chunghye98/CS-Archive/assets/57451700/1da85118-9b3d-4618-9402-8e98e8d7fb6f" width="40%">

## 참고
혼자 공부하는 컴퓨터구조 + 운영체제  
